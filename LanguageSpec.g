grammar LanguageSpec; 

ToplevelDeclaration: TypeDeclaration | Method | SimpleAttribute | AttributeGetter ;
TypeDeclaration: Class | Object | Interface ;
Declaration: Method | Attribute | TypeDeclaration ;
Import: 'import' FullPackageName '{' ImportElements? '}' ;
FullPackageName: PackageName ('.' PackageName)* ;
ImportElements: ImportElement (',' ImportElement)* (',' ImportWildcard)? | ImportWildcard ;
ImportElement: ImportTypeElement | ImportMethodAttributeElement ;
ImportTypeElement: TypeAlias? TypeName ;
ImportMethodAttributeElement: MethodAttributeAlias? MemberName ;
TypeAlias: TypeName '=' ;
MethodAttributeAlias: MemberName '=' ;
ImportWildcard: '...' ;
Introduction: 'adapt' Type SatisfiedTypes TypeConstraints? ';' ;
Interface: Annotation* InterfaceHeader (InterfaceBody | TypeSpecifier ';') ;
InterfaceHeader: 'interface' TypeName TypeParams? InterfaceInheritance TypeConstraints? ;
InterfaceInheritance: CaseTypes? Metatypes? AdaptedTypes? SatisfiedTypes? ;
InterfaceBody: '{' Declaration* '}' ;
TypeSpecifier: '=' Type ;
Class: Annotation* ClassHeader (ClassBody | TypeSpecifier ';') ;
ClassHeader: 'class' TypeName TypeParams? Params ClassInheritance TypeConstraints? ;
ClassInheritance: CaseTypes? Metatypes? ExtendedType? SatisfiedTypes? ;
ClassBody: '{' (Declaration | Statement)* '}' ;
Object: Annotation* ObjectHeader ClassBody ;
ObjectHeader: 'object' MemberName ObjectInheritance ;
ObjectInheritance: ExtendedType? SatisfiedTypes? ;
Method: Annotation* MethodHeader (Block | NamedArguments | Specifier? ';') ;
MethodHeader: (UnionType | 'function' | 'void') MemberName TypeParams? Params+ Metatypes? TypeConstraints? ;
Attribute: Annotation* (SimpleAttribute | AttributeGetter | AttributeSetter) ;
AttributeHeader: (UnionType | 'value') MemberName ;
SimpleAttribute: AttributeHeader ( (Specifier | Initializer)? ';' | NamedArguments ) ;
Initializer: ':=' Expression ;
AttributeGetter: AttributeHeader Block ;
AttributeSetter: 'assign' MemberName Block ;
Literal: IntegerLiteral | FloatLiteral | CharacterLiteral | StringLiteral | QuotedLiteral ;
DateLiteral:  '\''  Digit{1,2} '/' Digit{1,2} '/' Digit{4}  '\'' ;
TimeLiteral:  '\''  Digit{1,2} ':' Digit{2} ( ':' Digit{2} ( ':' Digit{3} )? )?  (' ' 'AM'|'PM')?  (' ' Character{3,4})?  '\'' ;
TypedQuotedLiteral: TypeName QuotedLiteral ;
StringTemplate: StringLiteral (Expression StringLiteral)+ ;
SelfReference: 'this' | 'super' | 'outer' ;
Atom: Literal | StringTemplate | SelfReference | ParExpression ;
Primary: Atom | Meta | MemberReference | Invocation ;
MemberReference: CallableReference | ValueReference ;
Expression: Primary /* | OperatorExpression */ ;
ParExpression: '(' Expression ')' ;
Receiver: Primary ;
OuterReference: (Receiver '.')? 'outer' ;
ValueReference: (Receiver '.')? MemberName ;
CallableReference: MethodReference | InitializerReference ;
MethodReference: (Receiver '.')? MemberName TypeArguments? ;
InitializerReference: (Receiver '.')? TypeName TypeArguments? ;
Invocation: Primary Arguments | SequenceInstantiation ;
Arguments: PositionalArguments FunctionalArguments? | NamedArguments ;
PositionalArguments: '(' Expression (',' Expression)* (',' Sequence)? | Sequence? ')' ;
NamedArguments: '{' NamedArgument* Sequence? '}' ;
NamedArgument: SpecifiedNamedArgument | LocalNamedArgument | FunctionalNamedArgument | Object ;
SpecifiedNamedArgument: MemberName Specifier ';' ;
LocalNamedArgument: (UnionType | 'value') MemberName (Block | NamedArguments) ;
FunctionalNamedArgument: (UnionType | 'function' | 'void') MemberName Params+ (Block | NamedArguments) ;
SequenceInstantiation: '{' Sequence? '}' ;
Sequence: Expression (',' Expression)* | Expression '...' ;
FunctionalArguments: (MemberName FunctionalBody)+ ;
FunctionalBody: Params? ( Block | '(' Expression ')' ) ;
Meta: TypeMeta | MethodMeta | AttributeMeta | FunctionMeta | ValueMeta ;
TypeMeta: Type ;
FunctionMeta: MemberName TypeArguments? ;
MethodMeta: Type '.' MemberName TypeArguments? ;
ValueMeta: MemberName TypeArguments? ;
AttributeMeta: Type '.' MemberName ;
Whitespace: ' ' | Tab | Formfeed | Newline | Return ;
LineComment: ('//'|'#!') ~(Newline|Return)* (Return Newline | Return | Newline)? ;
MultilineComment: '/*' ( MultilineCommmentCharacter | MultilineComment )* '*/' ;
MultilineCommmentCharacter: ~('/'|'*') | ('/' ~'*') => '/' | ('*' ~'/') => '*' ;
IdentifierChar: LowercaseChar | UppercaseChar | Digit ;
Digit: '0'..'9' ;
LowercaseChar: 'a'..'z' | '_' ;
UppercaseChar: 'A'..'Z' ;
LIdentifier: LowercaseChar IdentifierChar* ;
UIdentifier: UppercaseChar IdentifierChar* ;
PIdentifier: LowercaseChar+ ;
IntegerLiteral: Digits Magnitude? ;
FloatLiteral: Digits ('.' FractionalDigits (Exponent | Magnitude | FractionalMagnitude)? | FractionalMagnitude) ;
Digits: Digit+ | Digit{1..3} ('_' Digit{3})+ ;
FractionalDigits: Digit+ | (Digit{3} '_')+ Digit{1..3}  ;
Exponent: ('E'|'e') ('+'|'-')? Digits ;
Magnitude: 'k' | 'M' | 'G' | 'T' | 'P' ;
FractionalMagnitude: 'm' | 'u' | 'n' | 'p' | 'f' ;
CharacterLiteral: '`' Character '`' ;
Character: ~('`' | '\\' | Tab | Formfeed | Newline | Return | Backspace) | EscapeSequence ;
EscapeSequence: '\\' ('b' | 't' | 'n' | 'f' | 'r' | '\\' | '\"' | '\'' | '`' ) ;
StringLiteral: '\"' StringCharacter* '\"' ;
StringCharacter: ~( '\\' | '\"' ) | EscapeSequence ;
QuotedLiteral: '\'' QuotedLiteralCharacter* '\'' ;
QuotedLiteralCharacter: ~('\'') ;
Block: '{' (Declaration | Statement)* '}' ;
Statement: ExpressionStatement | Specification | DirectiveStatement | ControlStructure ;
ExpressionStatement: ( Assignment | IncrementOrDecrement | Invocation ) ';' ;
Assignment: ':=' | '.=' | '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^='| '~=' | '&&=' | '||=' ;
IncrementOrDecrement: '--' | '++' ;
DirectiveStatement: Directive ';' ;
Directive: Return | Throw | Break | Continue ;
Return: 'return' Expression? ;
Break: 'break' ;
Continue: 'continue' ;
Throw: 'throw' Expression? ;
Retry: 'retry' ;
Specification: MemberName Specifier ';' ;
ControlStructure: IfElse | SwitchCaseElse | While | ForFail | TryCatchFinally ;
TypedVariable: UnionType MemberName ;
Variable: UnionType? MemberName ;
IteratorVariable: Variable | CallableVariable | EntryVariablePair ;
CallableVariable: (UnionType | 'void')? MemberName Params+ ;
EntryVariablePair: Variable '->' Variable ;
Condition: BooleanCondition | IsCondition | ExistsOrNonemptyCondition | SatisfiesCondition ;
BooleanCondition: Expression ;
IsCondition: 'is' (TypedVariable Specifier | UnionType MemberName) ;
ExistsOrNonemptyCondition: ('exists' | 'nonempty') (Variable Specifier | MemberName) ;
SatisfiesCondition: 'satisfies' Type Type ;
IfElse: If Else? ;
If: 'if' '(' Condition ')' Block ;
Else: 'else' (Block | IfElse) ;
SwitchCaseElse: Switch ( Cases | '{' Cases '}' ) ;
Switch: 'switch' '(' Expression ')' ;
Cases: CaseItem+ DefaultCaseItem? ;
CaseItem: 'case' '(' Case ')' Block ;
DefaultCaseItem: 'else' Block ;
Case: Expression (',' Expression)* | 'is' UnionType | 'satisfies' Type ;
ForFail: For Fail? ;
For: 'for' '(' ForIterator ')' Block ;
Fail: 'else' Block ;
ForIterator: IteratorVariable 'in' Expression ;
While: LoopCondition Block ;
LoopCondition: 'while' '(' Condition ')' ;
TryCatchFinally: Try Catch* Finally? ;
Try: 'try' ('(' Resource ')')? Block ;
Catch: 'catch' '(' Variable ')' Block ;
Finally: 'finally' Block ;
Resource: MemberName | InitializerReference Arguments | Variable Specifier  ;
PackageName: PIdentifier ;
TypeName: UIdentifier ;
MemberName: LIdentifier ;
UnionType: IntersectionType ('|' IntersectionType)* ;
IntersectionType: EntryType ('&' EntryType)* ;
TypeNameWithArguments: TypeName TypeArguments? ;
Type: TypeNameWithArguments ('.' TypeNameWithArguments)* ;
AbbreviatedType: Type Abbreviation* ;
Abbreviation: '?' | '[]' ;
EntryType: AbbreviatedType ('->' AbbreviatedType)? ;
ExtendedType: 'extends' ('super' '.')? Type PositionalArguments ;
SatisfiedTypes: 'satisfies' Type ('&' Type)* ;
ConditionalTypes: SatisfiedTypes Conditions ;
Conditions: 'if' '(' Condition ('&&' Condition)* ')' ;
CaseTypes: 'of' CaseType ('|' CaseType)* ;
CaseType: MemberName | Type ;
AdaptedTypes: 'adapts' Type ('&' Type)* ;
Metatypes: 'is' Type ('&' Type)* ;
TypeParams: '<' (TypeParam ',')* (TypeParam | SequencedTypeParam) '>' ;
TypeParam: Variance? TypeName ;
Variance: 'out' | 'in' ;
SequencedTypeParam: TypeName '...' ;
Subtype: 'subtype' | MemberName '.' 'subtype' ;
TypeConstraints: TypeConstraint+ ;
TypeConstraint: 'given' TypeName TypeParams? Params? TypeConstraintInheritance ;
TypeConstraintInheritance: CaseTypes? Metatypes? SatisfiedTypes? AbstractedType? ;
AbstractedType: 'abstracts' Type ;
ConcreteType: 'this' 'is' ;
TypeArguments: '<' (UnionType ',')* (UnionType | SequencedType) '>' ;
SequencedType: TypeName '...' ;
TypeArgument: UnionType | Dimension ;
Dimension: DimensionTerm ('+' DimensionTerm)* ;
DimensionTerm: (DimensionConstant '*')* DimensionAtom ;
DimensionAtom: DimensionConstant | DimensionVariable | ParenDimension ;
ParenDimension: '(' Dimension ')' ;
DimensionConstant: '#' IntegerLiteral ;
DimensionVariable: TypeName | '#' MemberName ;
Params:  '(' Param (',' Param)* (',' DefaultParam)* (',' SequencedParam)? |  DefaultParam (',' DefaultParam)* (',' SequencedParam)? |  SequencedParam? ')' ;
Param: Annotation* (SimpleParam | CallableParam | EntryParamPair) ;
SimpleParam: UnionType MemberName ;
CallableParam: (UnionType | 'void') MemberName Params+ ;
DefaultParam: Param Specifier ;
Specifier: '=' Expression ;
SequencedParam: Annotation* UnionType '...' MemberName ;
EntryParamPair: SimpleParam '->' SimpleParam ;
Annotation: MemberName ( Arguments | Literal+ )? ;
Tab: '\t' ;
Formfeed: '\f' ;
Newline: '\n' ;
Backspace: '\b' ;